#include <iostream>
#include <vector>
#include <cstdlib>
#include <fstream>
#include <ctime>

using namespace std;


void clearScreen () {
    cout << "\033[H\033[2J";
}

const unsigned KReset    (0);
const unsigned KNoir      (30);
const unsigned KRouge     (31);
const unsigned KVert      (32);
const unsigned KJaune     (33);
const unsigned KBleu      (34);
const unsigned KMAgenta   (35);
const unsigned KCyan      (36);
const unsigned KImpossible = 0;


void couleur (const unsigned & coul) {
    cout << "\033[" << coul <<"m";
}

typedef vector <unsigned> line;
typedef vector <line> mat;
struct maPosition {
    unsigned abs;
    unsigned ord;
};

int KNbCandies = 6;

void initGrid(mat &grid, const size_t &matSize) {
    grid.resize(matSize);
    for (size_t i = 0; i < matSize; i++) {
        grid[i].resize(matSize);
        for (size_t j = 0; j < matSize; j++) {
            grid[i][j] = rand() % KNbCandies + 1;
        }
    }
}


void modePvp (unsigned int score1, unsigned int score2, bool tourJ1, unsigned int coupsJ1, unsigned int coupsJ2) {
    couleur(KJaune); cout << " MODE PVP (5 coups chacun) " << endl;
    couleur(KRouge); cout << "J1: " << score1 << " pts (" << coupsJ1 << "/5 coups)";
    couleur(KReset); cout << " | ";
    couleur(KVert);  cout << "J2: " << score2 << " pts (" << coupsJ2 << "/5 coups)" << endl;
    couleur(KReset);
    cout << "C'est au tour de : ";

    if (tourJ1 == true) {
        cout << "JOUEUR 1";
    } else {
        cout << "JOUEUR 2";
    }

    cout << endl << endl;
}


void displayGrid(const mat &grid, const size_t &matSize, bool pvp, unsigned int score1,unsigned int score2, bool tourJ1,unsigned int coupsJ1,unsigned int coupsJ2, bool histoire, unsigned int niveau, unsigned objectif, bool hardcore, int coupsRestants) {
    clearScreen ();

    if (pvp) {
        modePvp(score1, score2, tourJ1, coupsJ1, coupsJ2);
    } else if (histoire) {
        couleur(KMAgenta); cout << " MODE HISTOIRE - Niveau " << niveau << endl;
        couleur(KReset); cout << "Score : " << score1 << " / ";
        couleur(KVert); cout << objectif << " points requis";
        couleur(KRouge); cout << " | [Ligne] [Colonne] Q pour quitter " << endl;
        couleur(KReset);
    } else if (hardcore) {
        couleur(KRouge); cout << "  MODE HARDCORE  " << endl;
        couleur(KReset); cout << "Objectif : 80 points | ";
        couleur(KRouge); cout << "Coups restants : " << coupsRestants << endl;
        couleur(KReset); cout << "Score actuel : " << score1 << endl;
        couleur(KReset);
    } else {
        couleur(KCyan); cout << " MODE SOLO (INFINI) " << endl;
        couleur(KRouge); cout << "Score actuel : " << score1 << " | [Ligne] [Colonne] Q pour quitter " << endl;
        couleur(KReset);
    }

    for (size_t i = 0; i < matSize; i++) {
        cout << i << " | ";
        for (size_t j = 0; j < matSize; j++) {
            switch (grid[i][j]) {
            case 1: couleur(KRouge);
                break;

            case 2: couleur(KVert);
                break;

            case 3: couleur(KBleu);
                break;

            case 4: couleur(KJaune);
                break;

            case 5: couleur(KMAgenta);
                break;

            case 6: couleur(KCyan);
                break;

            case 7: couleur(KNoir);
                break;
            }

            cout << grid[i][j] << " ";
        }
        couleur(KReset);
        cout << endl;
    }

    cout << "  --";
    for (size_t j = 0; j < matSize; j++) {
        cout << "--";
    }
    cout << endl << "    ";
    for (size_t j = 0; j < matSize; j++) {
        cout << j << " ";
    }
    cout << endl;
}

void makeAMove (mat & grid, const maPosition & pos, const char & direction) {
    unsigned i_base = pos.abs;
    unsigned j_base = pos.ord;


    unsigned i_destination = i_base;
    unsigned j_destination = j_base;

    switch (direction) {
    case 'Z': i_destination = i_base - 1;
        break;

    case 'S': i_destination = i_base + 1;
        break;

    case 'A': j_destination = j_base - 1;
        break;

    case 'E': j_destination = j_base + 1;
        break;
    }


    swap(grid[i_base][j_base], grid[i_destination][j_destination]);
}


bool atLeastThreeInAColumn (const mat & grid, maPosition & pos, unsigned & howMany) {
    size_t matSize = grid.size();
    for (size_t j = 0; j < matSize; ++j) {
        for (size_t i = 0; i < matSize - 2; ++i) {
            unsigned val = grid[i][j];

            if (val != KImpossible && grid[i + 1][j] == val && grid[i + 2][j] == val) {
                unsigned compteur = 3;
                for (size_t k = i + 3; k < matSize; ++k) {
                    if (grid[k][j] == val) {
                        compteur++;
                    } else {
                        break;
                    }
                }
                pos.abs = i;
                pos.ord = j;
                howMany = compteur;
                return true;
            }
        }
    }
    return false;
}

bool atLeastThreeInARow (const mat & grid, maPosition & pos, unsigned & howMany) {
    size_t matSize = grid.size();
    for (size_t i = 0; i < matSize; ++i) {
        for (size_t j = 0; j < matSize - 2; ++j) {
            unsigned val = grid[i][j];
            if (val != KImpossible && grid[i][j + 1] == val && grid[i][j + 2] == val) {
                unsigned compteur = 3;
                for (size_t k = j + 3; k < matSize; ++k) {
                    if (grid[i][k] == val) {
                        compteur++;
                    } else {
                        break;
                    }
                }
                pos.abs = i;
                pos.ord = j;
                howMany = compteur;
                return true;
            }
        }
    }
    return false;
}

void removalInColumn (mat & grid, const maPosition & pos, unsigned howMany) {
    const unsigned KImpossible = 0;
    unsigned ligne = pos.abs;
    unsigned colonne = pos.ord;
    size_t matSize = grid.size();

    for (size_t i = ligne + howMany; i < matSize; ++i) {
        grid[i - howMany][colonne] = grid[i][colonne];
    }
    for (size_t i = matSize - howMany; i < matSize; ++i) {
        grid[i][colonne] = KImpossible;
    }
    for (size_t i = 0; i < matSize; ++i) {
        if (grid[i][colonne] == KImpossible) {
            grid[i][colonne] = rand() % KNbCandies + 1;
        }
    }
}

void removalInRow(mat & grid, const maPosition & pos, unsigned howMany) {
    const unsigned KImpossible = 0;
    for (size_t j = pos.ord; j < pos.ord + howMany; ++j) {
        grid[pos.abs][j] = KImpossible;
    }
    for (size_t j = pos.ord; j < pos.ord + howMany; ++j) {
        for (size_t i = pos.abs; i > 0; --i) {
            if (grid[i][j] == KImpossible) {
                for (size_t k = i; k > 0; --k) {
                    grid[k][j] = grid[k-1][j];
                }
                grid[0][j] = KImpossible;
            }
        }
        if (grid[0][j] == KImpossible) {
            grid[0][j] = rand() % KNbCandies + 1;
        }
    }
}

void meilleurScorePvP(const string & nomFichier, unsigned score1, unsigned score2) {
    
    unsigned meilleurPartie;
    if (score1 > score2) {
        meilleurPartie = score1;
    } else {
        meilleurPartie = score2;
    }

    unsigned ancienScore;
    ifstream fichierLecture(nomFichier);
    if (fichierLecture) {
        fichierLecture >> ancienScore;
    } else {
        ofstream fichierEcriture(nomFichier);
        fichierEcriture << meilleurPartie;
        cout << "Nouveau Score PvP : " << meilleurPartie << endl;
    }
}

void meilleurScoreInfini(const string & nomFichier, unsigned scorePartie) {
    unsigned meilleurScore = 0;
   
    ifstream fichierLecture(nomFichier);
    if (fichierLecture) {
        fichierLecture >> meilleurScore;
    } 

    if (scorePartie > meilleurScore) {
        ofstream fichierEcriture(nomFichier);
        fichierEcriture << scorePartie;
        cout << "Nouveau Meilleur Score Solo : " << scorePartie << " ! " << endl;
    } else {
        cout << "Meilleur Score Solo actuel : " << meilleurScore << endl;
    }
}

void meilleurScoreHardcore(const string & nomFichier, unsigned scorePartie) {
    unsigned meilleurScore = 0;
   
    ifstream fichierLecture(nomFichier);
    if (fichierLecture) {
        fichierLecture >> meilleurScore;
    } 

    if (scorePartie > meilleurScore) {
        ofstream fichierEcriture(nomFichier);
        fichierEcriture << scorePartie;
        cout << "Nouveau Meilleur Score Hardcore : " << scorePartie << " ! " << endl;
    } else {
        cout << "Meilleur Score Hardcore actuel : " << meilleurScore << endl;
    }
}

void meilleurScoreHistoire(const string & nomFichier, unsigned scorePartie, unsigned niveau) {
    vector<unsigned> Scores(3, 0);
   
    ifstream fichierLecture(nomFichier);
    if (fichierLecture) {
        for (unsigned i = 0; i < 3; ++i) {
            fichierLecture >> Scores[i];
        }
    } 

    if (scorePartie > Scores[niveau-1]) {
        Scores[niveau-1] = scorePartie;
        ofstream fichierEcriture(nomFichier);
        for (unsigned i = 0; i < 3; ++i) {
            fichierEcriture << Scores[i] << endl;
        }
        cout << "Nouveau Meilleur Score Histoire : " << scorePartie << " (Niveau " << niveau << " )" << endl;
    } 
    unsigned meilleurScore = 0;
    unsigned meilleurNiveau = 0;
    for (unsigned i = 0; i < 3; ++i) {
        if (Scores[i] > meilleurScore) {
            meilleurScore = Scores[i];
            meilleurNiveau = i + 1;
        }
    }
    cout << "Meilleur Score Histoire actuel : " << meilleurScore << " (Niveau " << meilleurNiveau << " )" << endl;
}

void niveau1(mat & grille, size_t & taille) {
    taille = 5;
    grille = {
        {1, 2, 1, 2, 1},
        {3, 4, 3, 4, 3},
        {1, 3, 2, 4, 1},
        {2, 1, 4, 3, 2},
        {4, 2, 3, 1, 4}
    };
}

void niveau2(mat & grille, size_t & taille) {
    taille = 7;
    grille = {
        {1,1,2,2,3,3,4},
        {2,2,3,3,4,4,1},
        {3,3,4,4,1,1,2},
        {4,4,1,1,2,2,3},
        {1,2,3,4,1,2,3},
        {2,3,4,1,2,3,4},
        {3,4,1,2,3,4,1}
    };
}

void niveau3(mat & grille, size_t & taille) {
    taille = 9;
    grille = {
        {1, 2, 3, 4, 5, 1, 2, 3, 4},
        {2, 3, 4, 5, 1, 2, 3, 4, 5},
        {3, 4, 5, 1, 2, 3, 4, 5, 1},
        {4, 5, 1, 2, 3, 4, 5, 1, 2},
        {5, 1, 2, 3, 4, 5, 1, 2, 3},
        {1, 2, 3, 4, 5, 1, 2, 3, 4},
        {2, 3, 4, 5, 1, 2, 3, 4, 5},
        {3, 4, 5, 1, 2, 3, 4, 5, 1},
        {4, 5, 1, 2, 3, 4, 5, 1, 2}
    };
}

unsigned objectifScore(unsigned int niveau) {
    if (niveau == 1) {
        return 50;
    } else if (niveau == 2) {
        return 100;
    } else if (niveau == 3) {
        return 150;
    }
    return 0;
}



void histoire(unsigned int niveau) {
    clearScreen ();
    couleur(KBleu);

    if (niveau == 1) {
        cout << "Vous etes un aventurier, partez a l'aventure et finissez tous les donjons !" << endl;
        cout << "Niveau 1 : donjon pour les nuls\n" << endl;
        cout << "Vous entrez dans le premier donjon, votre but ici est d'éliminer 40 ennemis, si vous échouez ici," << endl;
        cout << "ne tentez plus de rejouer a ce jeu, faites kebabiste" << endl;
    } else if (niveau == 2) {
        cout << "Niveau 2 : Donjon moyen\n" << endl;
        cout << "Vous arrivez devant ce nouveau donjon et vous vous rendez compte que votre meilleur ami" << endl;
        cout << "y est enfermé, tentez de le liberer et accedez au dernier niveau !" << endl;
    } else if (niveau == 3) {
        cout << "Niveau 3 : Sauvez la princesse\n" << endl;
        cout << "Vous etes dans le donjon le plus dangereux, faites attention" << endl;
        cout << "Il faudra y sauver la princesse, mais pour cela, il faudra etre prudent" << endl;
    }
    couleur(KReset);
    cout << "\nAppuyez sur Entrée pour continuer..." << endl;
    cin.get();
}

void introduction() {
    couleur(KRouge);
    cout << "Bienvenue dans Candy Crush!\n" << endl;
    couleur(KVert);
    cout << "Le but du jeu est d'aligner au moins trois bonbons de la meme couleur pour les faire disparaitre et marquer des points.\n" << endl;
    couleur(KBleu);

    cout << "Deplace un bonbon avec Z (haut), S (bas), A (gauche), E (droite)\n" << endl;
    couleur(KJaune);
    cout << "Chaque bonbon supprime rapporte deux points.\n" << endl;
    couleur(KCyan);
    cout << "Amusez-vous bien!\n" << endl;

    cout << "Appuyez sur Entree pour commencer le jeu..." << endl;
    cin.ignore();
}

int main()
{
    introduction();

    int mode;
    cout << "CHOISISSEZ LE MODE DE JEU :" << endl;
    cout << "1. Mode Solo (Infini)" << endl;
    cout << "2. Mode PvP (5 coups chacun)" << endl;
    cout << "3. Mode Histoire (3 Niveaux)" << endl;
    cout << "4. Mode HARDCORE " << endl;
    cout << "Votre choix : ";
    cin >> mode;

    bool estPvP = (mode == 2);
    bool modeHistoire = (mode == 3);
    bool modeHardcore = (mode == 4);

    unsigned int scoreJ1 = 0;
    unsigned int scoreJ2 = 0;
    unsigned int coupsJ1 = 0;
    unsigned int coupsJ2 = 0;
    int coupsRestantsHardcore = 10;
    bool tourJoueur1 = true;
    int niveau = 1;

    size_t t_grille = 5;
    mat mat_grille;

    if (modeHistoire) {
        histoire(niveau);
        niveau1(mat_grille, t_grille);
    } else if (modeHardcore) {
        KNbCandies = 7;
        t_grille = 6;
        initGrid(mat_grille, t_grille);
    } else {
        initGrid(mat_grille, t_grille);
    }

    unsigned i_abs, j_ord;
    char direction;
    bool jeu = true;
    maPosition pos_bonbons;
    unsigned nb_bonbons_sup;

    while (jeu) {

        unsigned objectif = 0;

        if (modeHistoire) {
            objectif = objectifScore(niveau);
        }

        displayGrid(mat_grille, t_grille, estPvP, scoreJ1, scoreJ2, tourJoueur1, coupsJ1, coupsJ2, modeHistoire, niveau, objectif, modeHardcore, coupsRestantsHardcore);


        if (estPvP && coupsJ1 >= 5 && coupsJ2 >= 5) {
            if (scoreJ1 > scoreJ2)
                cout << "VICTOIRE DU JOUEUR 1 !" << endl;
            else if (scoreJ2 > scoreJ1)
                cout << "VICTOIRE DU JOUEUR 2 !" << endl;
            else
                cout << "EGALITE !" << endl;
            break;
        }

        if (modeHardcore && coupsRestantsHardcore <= 0) {
            if (scoreJ1 >= 80) cout << "MODE HARDCORE REUSSI !" << endl;
            else cout << "Score insuffisant." << endl;
            break;
        }

        if (modeHistoire && direction == 'Q') {
            cout << "Fin du mode Histoire ! " << endl;
            break;
        }

        if (mode == 1 && direction == 'Q') {
            cout << "Fin du mode Solo ! " << endl;
            break;
        }
        cout << "\nEntrez [Ligne] [Colonne] [Direction (AZES)]  ";
        cin >> i_abs;
        cin >> j_ord;
        cin >> direction;

        maPosition pos = {i_abs, j_ord};
        makeAMove(mat_grille, pos, direction);

        if (estPvP) {
            if (tourJoueur1)
                coupsJ1++;
            else
                coupsJ2++;
        }

        if (modeHardcore) {
            coupsRestantsHardcore--;
        }

        bool encore;
        do {
            encore = false;
            if (atLeastThreeInAColumn(mat_grille, pos_bonbons, nb_bonbons_sup)) {
                removalInColumn(mat_grille, pos_bonbons, nb_bonbons_sup);
                if (tourJoueur1)
                    scoreJ1 += nb_bonbons_sup * 2;
                else
                    scoreJ2 += nb_bonbons_sup * 2;

                cout << "\n Il y a  " << nb_bonbons_sup << "  bonbons supprimes. \n";
                encore = true;
            } else if (atLeastThreeInARow(mat_grille, pos_bonbons, nb_bonbons_sup)) {
                removalInRow(mat_grille, pos_bonbons, nb_bonbons_sup);

                if (tourJoueur1)
                    scoreJ1 += nb_bonbons_sup * 2;
                else
                    scoreJ2 += nb_bonbons_sup * 2;
                cout << "\n il y a  " << nb_bonbons_sup << "  bonbons supprimes. \n";
                encore = true;
            }
        } while (encore);



        if (modeHistoire && scoreJ1 >= objectif) {
            cout << "\n Bravo ! Vous avez réussi !" << endl;
            niveau++;

            if (niveau > 3) {
                cout << "VOUS AVEZ FINI TOUTE L'HISTOIRE ! BRAVO !" << endl;
                jeu = false;
            } else {
                scoreJ1 = 0;
                histoire(niveau);
                if (niveau == 2) niveau2(mat_grille, t_grille);
                else if (niveau == 3) niveau3(mat_grille, t_grille);
            }
            continue;
        }


        if (estPvP) {
            tourJoueur1 = !tourJoueur1;
        }
    }
    
    if (estPvP) {
        meilleurScorePvP("pvp_scores.txt", scoreJ1, scoreJ2);
    } else if (modeHistoire) {
        meilleurScoreHistoire("histoire_scores.txt", scoreJ1);
    } else if (modeHardcore) {
        meilleurScoreHardcore("hardcore_scores.txt", scoreJ1);
    } else {
        meilleurScoreInfini("infini_scores.txt", scoreJ1);
    }

    return 0;
}
