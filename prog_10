#include <iostream>
#include <vector>
#include <cstdlib>
#include <fstream>
#include <ctime>

using namespace std;


void clearScreen () {
    cout << "\033[H\033[2J";
}

const unsigned KReset    (0);
const unsigned KNoir      (30);
const unsigned KRouge     (31);
const unsigned KVert      (32);
const unsigned KJaune     (33);
const unsigned KBleu      (34);
const unsigned KMAgenta   (35);
const unsigned KCyan      (36);
const unsigned KImpossible = 0;

void couleur (const unsigned & coul) {
    cout << "\033[" << coul <<"m";
}

typedef vector <unsigned> line;
typedef vector <line> mat;
struct maPosition {
    unsigned abs;
    unsigned ord;
};

int KNbCandies = 6;

void initGrid(mat &grid, const size_t &matSize) {
    grid.resize(matSize);
    for (size_t i = 0; i < matSize; i++) {
        grid[i].resize(matSize);
        for (size_t j = 0; j < matSize; j++) {
            grid[i][j] = rand() % KNbCandies + 1;
        }
    }
}


void modePvp (unsigned int score1, unsigned int score2, bool tourJ1, unsigned int coupsJ1, unsigned int coupsJ2) {
    couleur(KJaune); cout << " MODE PVP (5 coups chacun) " << endl;
    couleur(KRouge); cout << "J1: " << score1 << " pts (" << coupsJ1 << "/5 coups)";
    couleur(KReset); cout << " | ";
    couleur(KVert);  cout << "J2: " << score2 << " pts (" << coupsJ2 << "/5 coups)" << endl;
    couleur(KReset);
    cout << "C'est au tour de : ";

    if (tourJ1 == true) {
        cout << "JOUEUR 1";
    } else {
        cout << "JOUEUR 2";
    }

    cout << endl << endl;
}


void displayGrid(const mat &grid, const size_t &matSize, bool pvp, unsigned int score1,unsigned int score2, bool tourJ1,unsigned int coupsJ1,unsigned int coupsJ2, bool histoire, unsigned int niveau, unsigned objectif, bool hardcore, int coupsRestants,bool ContreLaMontre, int tempsRestant) {
    clearScreen ();

    if (pvp) {
        modePvp(score1, score2, tourJ1, coupsJ1, coupsJ2);
    } else if (histoire) {
        couleur(KMAgenta); cout << " MODE HISTOIRE - Niveau " << niveau << endl;
        couleur(KReset); cout << "Score : " << score1 << " / ";
        couleur(KVert); cout << objectif << " points requis" << endl;
        couleur(KReset);
    } else if (hardcore) {
        couleur(KRouge); cout << "  MODE HARDCORE  " << endl;
        couleur(KReset); cout << "Objectif : 80 points | ";
        couleur(KRouge); cout << "Coups restants : " << coupsRestants << endl;
        couleur(KReset); cout << "Score actuel : " << score1 << endl;
        couleur(KReset);
    } else if (ContreLaMontre)
    {
        couleur(KBleu); cout << " MODE CONTRE LA MONTRE  " << endl;
        couleur(KReset); cout << "Objectif : 100 points | ";
        couleur(KRouge); cout << "Temps restant : " << tempsRestant << " secondes | ";
        couleur(KReset); cout << "Score actuel : " << score1 << endl;
        couleur(KReset);
    } else {
        couleur(KCyan); cout << " MODE SOLO (INFINI) " << endl;
        couleur(KRouge); cout << "Score actuel : " << score1 << endl;
        couleur(KReset);
    }

    for (size_t i = 0; i < matSize; i++) {
        cout << i << " | ";
        for (size_t j = 0; j < matSize; j++) {
            switch (grid[i][j]) {
            case 1: couleur(KRouge);
                break;

            case 2: couleur(KVert);
                break;

            case 3: couleur(KBleu);
                break;

            case 4: couleur(KJaune);
                break;

            case 5: couleur(KMAgenta);
                break;

            case 6: couleur(KCyan);
                break;


            case 7: couleur(KNoir);
                break;
            }

            cout << grid[i][j] << " ";
        }
        couleur(KReset);
        cout << endl;
    }

    cout << "  --";
    for (size_t j = 0; j < matSize; j++) {
        cout << "--";
    }
    cout << endl << "    ";
    for (size_t j = 0; j < matSize; j++) {
        cout << j << " ";
    }
    cout << endl;
}

void makeAMove (mat & grid, const maPosition & pos, const char & direction) {
    unsigned i_base = pos.abs;
    unsigned j_base = pos.ord;


    unsigned i_destination = i_base;
    unsigned j_destination = j_base;

    switch (direction) {
    case 'Z': i_destination = i_base - 1;
        break;

    case 'S': i_destination = i_base + 1;
        break;

    case 'A': j_destination = j_base - 1;
        break;

    case 'E': j_destination = j_base + 1;
        break;
    }


    swap(grid[i_base][j_base], grid[i_destination][j_destination]);
}


bool atLeastThreeInAColumn (const mat & grid, maPosition & pos, unsigned & howMany) {
    size_t matSize = grid.size();
    for (size_t j = 0; j < matSize; ++j) {
        for (size_t i = 0; i < matSize - 2; ++i) {
            unsigned val = grid[i][j];

            if (val != KImpossible && grid[i + 1][j] == val && grid[i + 2][j] == val) {
                unsigned compteur = 3;
                for (size_t k = i + 3; k < matSize; ++k) {
                    if (grid[k][j] == val) {
                        compteur++;
                    } else {
                        break;
                    }
                }
                pos.abs = i;
                pos.ord = j;
                howMany = compteur;
                return true;
            }
        }
    }
    return false;
}

bool atLeastThreeInARow (const mat & grid, maPosition & pos, unsigned & howMany) {
    size_t matSize = grid.size();
    for (size_t i = 0; i < matSize; ++i) {
        for (size_t j = 0; j < matSize - 2; ++j) {
            unsigned val = grid[i][j];
            if (val != KImpossible && grid[i][j + 1] == val && grid[i][j + 2] == val) {
                unsigned compteur = 3;
                for (size_t k = j + 3; k < matSize; ++k) {
                    if (grid[i][k] == val) {
                        compteur++;
                    } else {
                        break;
                    }
                }
                pos.abs = i;
                pos.ord = j;
                howMany = compteur;
                return true;
            }
        }
    }
    return false;
}

void removalInColumn (mat & grid, const maPosition & pos, unsigned howMany) {
    const unsigned KImpossible = 0;
    unsigned ligne = pos.abs;
    unsigned colonne = pos.ord;
    size_t matSize = grid.size();

    for (size_t i = ligne + howMany; i < matSize; ++i) {
        grid[i - howMany][colonne] = grid[i][colonne];
    }
    for (size_t i = matSize - howMany; i < matSize; ++i) {
        grid[i][colonne] = KImpossible;
    }
    for (size_t i = 0; i < matSize; ++i) {
        if (grid[i][colonne] == KImpossible) {
            grid[i][colonne] = rand() % KNbCandies + 1;
        }
    }
}

void removalInRow(mat & grid, const maPosition & pos, unsigned howMany) {
    const unsigned KImpossible = 0;
    for (size_t j = pos.ord; j < pos.ord + howMany; ++j) {
        grid[pos.abs][j] = KImpossible;
    }
    for (size_t j = pos.ord; j < pos.ord + howMany; ++j) {
        for (size_t i = pos.abs; i > 0; --i) {
            if (grid[i][j] == KImpossible) {
                for (size_t k = i; k > 0; --k) {
                    grid[k][j] = grid[k-1][j];
                }
                grid[0][j] = KImpossible;
            }
        }
        if (grid[0][j] == KImpossible) {
            grid[0][j] = rand() % KNbCandies + 1;
        }
    }
}


unsigned score = 0;

void lireScore(const string & filename) {
    ifstream fichier(filename);
    if (fichier) {
        fichier >> score;
        fichier.close();
    }
}

void sauvegarderScore(const string & filename) {
    ofstream fichier(filename);
    if (fichier) {
        fichier << score;
        fichier.close();
    }
}

void meilleurScore(const string & filename, const unsigned & nouveauScore) {
    unsigned ancienActuel = 0;

    ifstream fichierLecture(filename);
    if (fichierLecture) {
        fichierLecture >> ancienActuel;
        fichierLecture.close();
    }

    if (nouveauScore > ancienActuel) {
        ofstream fichierEcriture(filename);
        if (fichierEcriture) {
            fichierEcriture << nouveauScore;
            cout << "Nouveau meilleur score: " << nouveauScore << "!" << endl;
        } else {
            cout << "Meilleur score actuel: " << ancienActuel << endl;
        }
    }
}


void niveau1(mat & grille, size_t & taille) {
    taille = 5;
    grille = {
        {1, 2, 1, 2, 1},
        {3, 4, 3, 4, 3},
        {1, 3, 2, 4, 1},
        {2, 1, 4, 3, 2},
        {4, 2, 3, 1, 4}
    };
}

void niveau2(mat & grille, size_t & taille) {
    taille = 7;
    grille = {
        {1,1,2,2,3,3,4},
        {2,2,3,3,4,4,1},
        {3,3,4,4,1,1,2},
        {4,4,1,1,2,2,3},
        {1,2,3,4,1,2,3},
        {2,3,4,1,2,3,4},
        {3,4,1,2,3,4,1}
    };
}

void niveau3(mat & grille, size_t & taille) {
    taille = 9;
    grille = {
        {1, 2, 3, 4, 5, 1, 2, 3, 4},
        {2, 3, 4, 5, 1, 2, 3, 4, 5},
        {3, 4, 5, 1, 2, 3, 4, 5, 1},
        {4, 5, 1, 2, 3, 4, 5, 1, 2},
        {5, 1, 2, 3, 4, 5, 1, 2, 3},
        {1, 2, 3, 4, 5, 1, 2, 3, 4},
        {2, 3, 4, 5, 1, 2, 3, 4, 5},
        {3, 4, 5, 1, 2, 3, 4, 5, 1},
        {4, 5, 1, 2, 3, 4, 5, 1, 2}
    };
}

unsigned objectifScore(unsigned int niveau) {
    if (niveau == 1) {
        return 40;
    } else if (niveau == 2) {
        return 100;
    } else if (niveau == 3) {
        return 150;
    }
    return 0;
}



void histoire(unsigned int niveau) {
    clearScreen ();
    couleur(KBleu);

    if (niveau == 1) {
        cout << "Vous etes un aventurier, partez a l'aventure et finissez tous les donjons !" << endl;
        cout << "Niveau 1 : donjon pour les nuls\n" << endl;
        cout << "Vous entrez dans le premier donjon, votre but ici est d'éliminer 40 ennemis, si vous échouez ici," << endl;
        cout << "ne tentez plus de rejouer a ce jeu, faites kebabiste" << endl;
    } else if (niveau == 2) {
        cout << "Niveau 2 : Donjon moyen\n" << endl;
        cout << "Vous arrivez devant ce nouveau donjon et vous vous rendez compte que votre meilleur ami," << endl;
        cout << "y est enfermé, tentez de le liberer et accedez au dernier niveau !" << endl;
    } else if (niveau == 3) {
        cout << "Niveau 3 : Sauvez la princesse\n" << endl;
        cout << "Vous etes dans le donjon le plus dangereux, faites attention" << endl;
        cout << "Il faudra y sauver la princesse, mais pour cela, il faudra etre prudent" << endl;
    }
    couleur(KReset);
    cout << "\nAppuyez sur Entrée pour continuer..." << endl;
    cin.get();
}

void introduction() {
    couleur(KRouge);
    cout << "Bienvenue dans Candy Crush!\n" << endl;
    couleur(KVert);
    cout << "Le but du jeu est d'aligner au moins trois bonbons de la meme couleur pour les faire disparaitre et marquer des points.\n" << endl;
    couleur(KBleu);

    cout << "Deplace un bonbon avec Z (haut), S (bas), A (gauche), E (droite)\n" << endl;
    couleur(KJaune);
    cout << "Chaque bonbon supprime rapporte deux points.\n" << endl;
    couleur(KReset);
    cout << "Amusez-vous bien!\n" << endl;

    cout << "Appuyez sur Entree pour commencer le jeu..." << endl;
    cin.ignore();
}

int main()
{
    introduction();

    lireScore("scores.txt");
    cout << "Votre score est de : " << score << endl;
    srand(time(0));

    int mode;
    cout << "CHOISISSEZ LE MODE DE JEU :" << endl;
    cout << "1. Mode Solo (Infini)" << endl;
    cout << "2. Mode PvP (5 coups chacun)" << endl;
    cout << "3. Mode Histoire (3 Niveaux)" << endl;
    cout << "4. Mode HARDCORE " << endl;
    cout << "5. Mode Contre la Montre (60 secondes)" << endl;
    cout << "Votre choix : ";
    cin >> mode;

    bool estPvP = (mode == 2);
    bool modeHistoire = (mode == 3);
    bool modeHardcore = (mode == 4);
    bool modeContreLaMontre = (mode == 5);

    unsigned int scoreJ1 = 0;
    unsigned int scoreJ2 = 0;
    unsigned int coupsJ1 = 0;
    unsigned int coupsJ2 = 0;
    int coupsRestantsHardcore = 10;
    int tempsRestantMontre;
    bool tourJoueur1 = true;
    int niveauActuel = 1;

    time_t tempsDebut, tempsActuel;
    int dureeDeLaMontre = 60;
    tempsActuel = time(0);
    tempsDebut = time(0);
    tempsRestantMontre = dureeDeLaMontre - (tempsActuel - tempsDebut);
    
    size_t t_grille = 5;
    mat mat_grille;

    if (modeHistoire) {
        histoire(niveauActuel);
        niveau1(mat_grille, t_grille);
    } else if (modeHardcore) {
        KNbCandies = 7;
        t_grille = 6;
        initGrid(mat_grille, t_grille);
    } else if (modeContreLaMontre) {
        KNbCandies = 7;
        t_grille = 6;
        initGrid(mat_grille, t_grille);
    } else {
        initGrid(mat_grille, t_grille);
    }

    unsigned i_abs, j_ord;
    char direction;
    bool jeu = true;
    maPosition pos_match;
    unsigned nb_match;

    while (jeu) {

        unsigned objectif = 0;

        if (modeHistoire) {
            objectif = objectifScore(niveauActuel);
        }

        displayGrid(mat_grille, t_grille, estPvP, scoreJ1, scoreJ2, tourJoueur1, coupsJ1, coupsJ2, modeHistoire, niveauActuel, objectif, modeHardcore, modeContreLaMontre, coupsRestantsHardcore, tempsRestantMontre);


        if (estPvP && coupsJ1 >= 5 && coupsJ2 >= 5) {
            if (scoreJ1 > scoreJ2) cout << "VICTOIRE DU JOUEUR 1 !" << endl;
            else if (scoreJ2 > scoreJ1) cout << "VICTOIRE DU JOUEUR 2 !" << endl;
            else cout << "EGALITE !" << endl;
            break;
        }

        if (modeHardcore && coupsRestantsHardcore <= 0) {
            if (scoreJ1 >= 80) cout << "MODE HARDCORE REUSSI !" << endl;
            else cout << " Score insuffisant." << endl;
            break;
        }

        if (modeContreLaMontre && tempsRestantMontre) {
            tempsActuel = time(0);
            tempsRestantMontre = dureeDeLaMontre - (tempsActuel - tempsDebut);
            
            if (scoreJ1 >= 100) {
                cout << "MODE CONTRE LA MONTRE REUSSI !" << endl;
                break;
            } else if (tempsRestantMontre <= 0) {
                cout << "TEMPS ECOULE !" << endl;
                if (scoreJ1 < 100) {
                    cout << " Vous n'avez pas atteint 100 points." << endl;
                }
            }
            
        }
        cout << "\nEntrez [Ligne] [Colonne] [Direction (AZES)]  ";
        cin >> i_abs;
        cin >> j_ord;
        cin >> direction;

        maPosition pos = {i_abs, j_ord};
        makeAMove(mat_grille, pos, direction);

        if (estPvP) {
            if (tourJoueur1) coupsJ1++;
            else coupsJ2++;
        }

        if (modeHardcore) {
            coupsRestantsHardcore--;
        }

        bool encore;
        do {
            encore = false;
            if (atLeastThreeInAColumn(mat_grille, pos_match, nb_match)) {
                removalInColumn(mat_grille, pos_match, nb_match);

                if (tourJoueur1) scoreJ1 += nb_match * 2;
                else scoreJ2 += nb_match * 2;
                cout << "\n Il y a  " << nb_match << "  bonbons supprimes. \n";
                encore = true;
            } else if (atLeastThreeInARow(mat_grille, pos_match, nb_match)) {
                removalInRow(mat_grille, pos_match, nb_match);

                if (tourJoueur1) scoreJ1 += nb_match * 2;
                else scoreJ2 += nb_match * 2;
                cout << "\n il y a  " << nb_match << "  bonbons supprimes. \n";
                encore = true;
            }
        } while (encore);



        if (modeHistoire && scoreJ1 >= objectif) {
            cout << "\n Bravo ! Vous avez réussi !" << endl;
            niveauActuel++;

            if (niveauActuel > 3) {
                cout << "VOUS AVEZ FINI TOUTE L'HISTOIRE ! BRAVO !" << endl;
                jeu = false;
            } else {
                scoreJ1 = 0;
                histoire(niveauActuel);
                if (niveauActuel == 2) niveau2(mat_grille, t_grille);
                else if (niveauActuel == 3) niveau3(mat_grille, t_grille);
            }
            continue;
        }


        if (estPvP) {
            tourJoueur1 = !tourJoueur1;
        }
    }
    cout << "Score sauvegardé dans le fichier : ";
    lireScore("scores.txt");
    cout << score << endl;

    sauvegarderScore("scores.txt");
    meilleurScore("scores.txt", scoreJ1);

    return 0;
}
